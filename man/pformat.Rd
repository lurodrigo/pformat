% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pformat.R
\docType{package}
\name{pformat}
\alias{pformat}
\alias{pformat-package}
\title{pformat: brings Python-inspired string interpolation and formatting}
\usage{
pformat(format_string, ..., with = NULL)
}
\arguments{
\item{format_string}{a format string (See details for specification) or a
\code{pformat.compiled} object returned from \code{pformat_parse()}}

\item{with}{a \code{(pair)list}, \code{data.frame} or \code{environment} on 
which named fields or expressions can be evaluated}
}
\value{
returns a `character` vector with the output
}
\description{
blablabla

Perfoms string formatting and interpolation through
a format specification
}
\details{
Numbered fields start from 1 (not from 0, as in Python.)

Non-named fields (manually or automatically numbered) are evaluated only over
the list of arguments passed. You can't write expressions involving non-named
fields. In Python, you can write \code{"{0.real}".format(1+2j)}
and it will return a string with the real part of the number. You can't do
this here, it's a design choice. Allowing it would imply limiting the 
kind of expressions one could use as a field, and expressions surely provide
more power than numbered fields.

On placeholders, pformat looks for names first on keyword arguments, then 
as a member of the with argument object, and only then at the caller's
environment.
}
\examples{

pformat("{} {}", "one", "two")

pformat("{2} {1}", "one", "two")

pformat("Name: {}; Age: {}", c("Abby", "Bob", "Carl"), 22:24)
}

